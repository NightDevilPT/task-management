Prisma Code : generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum TeamInviteStatus {
  PENDING
  ACCEPTED
  DECLINED
} 

enum TeamRole {
  ADMIN
  MANAGER
  MEMBER
}

enum ProjectStatus {
  ACTIVE
  ARCHIVED
  COMPLETED
  ON_HOLD
}

enum TaskStatusEnum {
  TODO
  IN_PROGRESS
  REVIEW
  DONE
  BLOCKED
}

enum TaskPriorityEnum {
  LOW
  MEDIUM
  HIGH
  URGENT
}

model User {
  id           String   @id @default(cuid())
  firstName    String
  lastName     String
  username     String   @unique
  email        String   @unique
  avatar       String?  // URL to avatar image
  isVerified   Boolean  @default(false)
  password     String
  otp          Int?     // For JWT to verify email or reset password
  otpExpiry    DateTime? @map("otp_expiry") // Expiry time for the token
  refreshToken String?  // For JWT refresh tokens
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")
  lastLogin    DateTime?
  isActive     Boolean  @default(true)
  role         TeamRole @default(MEMBER)
  // Relations
  teamMemberships TeamMember[]
  createdTeams    Team[]      @relation("TeamOwner")
  createdTasks    Task[]      @relation("TaskCreator")
  assignedTasks   Task[]      @relation("TaskAssignee")
  notifications   Notification[]
  activities      Activity[]
  teamInvites     TeamInvite[]
  comments        Comment[]
  attachments     Attachment[]
  createdProjects Project[] @relation("ProjectOwner")

  @@map("users")
}

model Project {
  id          String   @id @default(cuid())
  name        String
  description String?
  status      ProjectStatus @default(ACTIVE)
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  
  // Relations
  owner      User         @relation("ProjectOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId    String
  teams      Team[]
  tasks      Task[]
  activities Activity[]
  teamMembers TeamMember[] // Opposite relation for TeamMember.project
  teamInvites TeamInvite[] // Opposite relation for TeamInvite.project
  comments    Comment[]    // Opposite relation for Comment.project
  attachments Attachment[] // Opposite relation for Attachment.project
  notifications Notification[] // Opposite relation for Notification.project
  
  @@map("projects")
}

model Team {
  id          String   @id @default(cuid())
  name        String
  description String?
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  
  // Relations
  owner      User         @relation("TeamOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId    String
  project    Project      @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId  String
  members    TeamMember[]
  tasks      Task[]
  invites    TeamInvite[]
  activities Activity[]
  
  @@map("teams")
}

model TeamMember {
  id        String   @id @default(cuid())
  role      TeamRole @default(MEMBER)
  joinedAt  DateTime @default(now()) @map("joined_at")
  
  // Relations
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  team      Team    @relation(fields: [teamId], references: [id], onDelete: Cascade)
  teamId    String
  project   Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId String
  
  @@unique([userId, teamId])
  @@unique([userId, projectId, teamId]) // Ensure unique membership per project-team combination
  @@map("team_members")
}

model TeamInvite {
  id        String   @id @default(cuid())
  email     String
  role      TeamRole @default(MEMBER)
  token     String   @unique
  status   TeamInviteStatus   @default(PENDING) // e.g., PENDING, ACCEPTED, DECLINED
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")
  
  // Relations
  team      Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)
  teamId    String
  project   Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId String
  invitedBy User   @relation(fields: [invitedById], references: [id], onDelete: Cascade)
  invitedById String
  
  @@unique([email, teamId])
  @@map("team_invites")
}

model Task {
  id          String   @id @default(cuid())
  title       String
  description String?
  status      TaskStatusEnum   @default(TODO)
  priority    TaskPriorityEnum   @default(MEDIUM)
  dueDate     DateTime? @map("due_date")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  
  // Relations
  assignedTo  User?   @relation("TaskAssignee", fields: [assignedToId], references: [id], onDelete: SetNull)
  assignedToId String?
  createdBy   User    @relation("TaskCreator", fields: [createdById], references: [id], onDelete: Cascade)
  createdById String
  team        Team?   @relation(fields: [teamId], references: [id], onDelete: Cascade)
  teamId      String?
  project     Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId   String
  comments    Comment[]
  attachments Attachment[]
  activities  Activity[]
  
  @@map("tasks")
}

model Comment {
  id        String   @id @default(cuid())
  content   String
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  
  // Relations
  author    User   @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId  String
  task      Task   @relation(fields: [taskId], references: [id], onDelete: Cascade)
  taskId    String
  project   Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId String
  
  @@map("comments")
}

model Attachment {
  id        String   @id @default(cuid())
  filename  String
  url       String
  size      Int
  type      String
  createdAt DateTime @default(now()) @map("created_at")
  
  // Relations
  task      Task   @relation(fields: [taskId], references: [id], onDelete: Cascade)
  taskId    String
  uploadedBy User  @relation(fields: [uploadedById], references: [id], onDelete: Cascade)
  uploadedById String
  project   Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId String
  
  @@map("attachments")
}

model Notification {
  id        String   @id @default(cuid())
  title     String
  message   String
  type      String   // e.g., "TASK_ASSIGNED", "INVITE_RECEIVED", "COMMENT_ADDED"
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now()) @map("created_at")
  
  // Relations
  user      User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  project   Project? @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId String?
  
  @@map("notifications")
}

model Activity {
  id        String   @id @default(cuid())
  action    String   // e.g., "CREATE_TASK", "UPDATE_TASK", "JOIN_TEAM"
  details   String?
  createdAt DateTime @default(now()) @map("created_at")
  
  // Relations
  user      User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  team      Team?  @relation(fields: [teamId], references: [id], onDelete: Cascade)
  teamId    String?
  task      Task?  @relation(fields: [taskId], references: [id], onDelete: Cascade)
  taskId    String?
  project   Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId String
  
  @@map("activities")
}

Reference Route Code
Create project Code : // app/api/projects/route.ts
import {
	TranslationEnum,
	TranslationErrorEnum,
} from "@/interface/translation-enums";
import {
	Action,
	PermissionService,
	ResourceType,
	TeamRole,
	UserContext,
} from "@/lib/permission";
import {
	ICreateProjectRequest,
	ProjectStatusEnum,
} from "@/interface/project.interface";
import { prisma } from "@/lib/prisma";
import { ApiResponse } from "@/interface/api.interface";
import { NextRequest, NextResponse } from "next/server";
import { withRequestTiming } from "@/middleware/timestamp.middleware";
import { withTokenValidation } from "@/middleware/cookie-validate.middleware";

// POST /api/projects - Creates a new project with permission checks
async function handleCreateProject(request: NextRequest) {
	try {
		const payload = (request as any)?.user;
		// Validate token payload
		if (!payload) {
			return NextResponse.json<ApiResponse>(
				{
					message: TranslationErrorEnum.UNAUTHORIZED,
					statusCode: 401,
					error: "Authentication Error",
				},
				{ status: 401 }
			);
		}

		// Fetch user details
		const user = await prisma.user.findUnique({
			where: { id: payload.id },
			select: {
				id: true,
				role: true, // Assumes role is a TeamRole field in User model
				email: true,
				isActive: true,
			},
		});

		// Check if user exists and is active
		if (!user || !user.isActive) {
			return NextResponse.json<ApiResponse>(
				{
					message: TranslationErrorEnum.USER_DOES_NOT_EXIST,
					statusCode: 404,
					error: "User Error",
				},
				{ status: 404 }
			);
		}

		// Verify permission to create a project
		const userContext: UserContext = {
			id: user.id,
			role: user.role as TeamRole,
		};

		if (
			!PermissionService.hasPermission(
				userContext,
				Action.CREATE,
				ResourceType.PROJECT
			)
		) {
			return NextResponse.json<ApiResponse>(
				{
					message: TranslationErrorEnum.PERMISSION_DENIED,
					statusCode: 403,
					error: "Permission Error",
				},
				{ status: 403 }
			);
		}

		// Parse and validate request body
		const { name, description, status }: ICreateProjectRequest =
			await request.json();

		if (!name?.trim()) {
			return NextResponse.json<ApiResponse>(
				{
					message: TranslationErrorEnum.ALL_FIELDS_ARE_REQUIRED,
					statusCode: 400,
					error: "Validation Error",
				},
				{ status: 400 }
			);
		}

		// Create the project
		const newProject = await prisma.project.create({
			data: {
				name: name.trim(),
				description: description?.trim(),
				ownerId: user.id,
				status:
					(status as ProjectStatusEnum) || ProjectStatusEnum.ACTIVE,
			},
			include: {
				owner: {
					select: {
						id: true,
						firstName: true,
						lastName: true,
						username: true,
						email: true,
						avatar: true,
					},
				},
			},
		});

		// Create a team for the project first
		const newTeam = await prisma.team.create({
			data: {
				name: `${newProject.name} Team`,
				projectId: newProject.id,
				ownerId: user.id,
			},
		});

		// Add the creator as a team member to the project
		await prisma.teamMember.create({
			data: {
				userId: user.id,
				teamId: newTeam.id, // Assuming teamId is projectId for initial membership
				role: user.role as TeamRole,
				projectId: newProject.id,
			},
		});

		// Return success response
		return NextResponse.json<ApiResponse>(
			{
				message: TranslationEnum.PROJECT_CREATED_SUCCESSFULLY,
				statusCode: 201,
				data: newProject,
			},
			{ status: 201 }
		);
	} catch (error: any) {
		console.error("Error creating project:", error);

		return NextResponse.json<ApiResponse>(
			{
				message: TranslationErrorEnum.INTERNAL_SERVER_ERROR,
				statusCode: 500,
				error: "Project Creation Error",
				errors: error.message ? [error.message] : undefined,
			},
			{ status: 500 }
		);
	}
}

// Wrap handler with token validation and request timing middleware
export const POST = withRequestTiming(withTokenValidation(handleCreateProject));

Create Team Code : import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { withTokenValidation } from "@/middleware/cookie-validate.middleware";
import { withRequestTiming } from "@/middleware/timestamp.middleware";
import { ApiResponse } from "@/interface/api.interface";
import {
	TranslationEnum,
	TranslationErrorEnum,
} from "@/interface/translation-enums";
import { PermissionChecks, TeamRole } from "@/lib/permission";

// ----------------- Create Team Handler -----------------
async function createTeamHandler(request: NextRequest) {
	try {
		const payload = (request as any)?.user;

		if (!payload) {
			const response: ApiResponse = {
				message: TranslationErrorEnum.UNAUTHORIZED,
				statusCode: 401,
				error: "Authentication Error",
			};
			return NextResponse.json(response, { status: 401 });
		}

		const body = await request.json();
		const { name, description, projectId } = body;

		// Validate input
		if (!name?.trim() || !projectId?.trim()) {
			const response: ApiResponse = {
				message: TranslationErrorEnum.ALL_FIELDS_ARE_REQUIRED,
				statusCode: 400,
				error: "Validation Error",
			};
			return NextResponse.json(response, { status: 400 });
		}

		const user = await prisma.user.findUnique({
			where: { id: payload.id },
			select: { id: true, role: true, isActive: true },
		});

		if (!user || !user.isActive) {
			const response: ApiResponse = {
				message: TranslationErrorEnum.USER_DOES_NOT_EXIST,
				statusCode: 404,
				error: "User Error",
			};
			return NextResponse.json(response, { status: 404 });
		}

		// Find project
		const project = await prisma.project.findUnique({
			where: { id: projectId },
			include: { owner: true },
		});

		if (!project) {
			const response: ApiResponse = {
				message: TranslationErrorEnum.PROJECT_NOT_FOUND,
				statusCode: 404,
				error: "Project Error",
			};
			return NextResponse.json(response, { status: 404 });
		}

		// Check permission
		const userContext = {
			id: user.id,
			role: user.role as TeamRole,
		};

		if (
			!PermissionChecks.canCreateTeam(userContext)
		) {
			const response: ApiResponse = {
				message: TranslationErrorEnum.FORBIDDEN,
				statusCode: 403,
				error: "Permission Error",
			};
			return NextResponse.json(response, { status: 403 });
		}

		// Create team
		const team = await prisma.team.create({
			data: {
				name: name.trim(),
				description: description?.trim(),
				projectId,
				ownerId: payload.id,
			},
		});

		// Add creator as team member (ADMIN or MANAGER based on role)
		await prisma.teamMember.create({
			data: {
				userId: payload.id,
				teamId: team.id,
				projectId: projectId,
				role: userContext.role,
			},
		});

		const response: ApiResponse = {
			message: TranslationEnum.TEAM_CREATED_SUCCESSFULLY,
			statusCode: 201,
			data: team,
		};
		return NextResponse.json(response, { status: 201 });
	} catch (error: any) {
		console.error("Create team error:", error);
		const response: ApiResponse = {
			message: TranslationErrorEnum.INTERNAL_SERVER_ERROR,
			statusCode: 500,
			error: "Team Creation Error",
			errors: error.message ? [error.message] : undefined,
		};
		return NextResponse.json(response, { status: 500 });
	}
}

// ----------------- Exports -----------------
export const POST = withRequestTiming(withTokenValidation(createTeamHandler));

Get Projects with Pagination Code : import {
	TranslationEnum,
	TranslationErrorEnum,
} from "@/interface/translation-enums";
import { prisma } from "@/lib/prisma";
import { ApiResponse } from "@/interface/api.interface";
import { NextRequest, NextResponse } from "next/server";
import { TeamRole, UserContext } from "@/lib/permission";
import { withRequestTiming } from "@/middleware/timestamp.middleware";
import { withTokenValidation } from "@/middleware/cookie-validate.middleware";

// GET /api/projects - Gets projects with pagination and permission checks
async function handleGetProjects(request: NextRequest): Promise<NextResponse> {
	try {
		const payload = (request as any)?.user;

		// Validate token payload
		if (!payload) {
			return NextResponse.json<ApiResponse>(
				{
					message: TranslationErrorEnum.UNAUTHORIZED,
					statusCode: 401,
					error: "Authentication Error",
				},
				{ status: 401 }
			);
		}

		// Extract query parameters
		const { searchParams } = new URL(request.url);
		const page = parseInt(searchParams.get("page") || "1");
		const limit = parseInt(searchParams.get("limit") || "10");
		const search = searchParams.get("search") || "";
		const status = searchParams.get("status") || "";
		const sortBy = searchParams.get("sortBy") || "createdAt";
		const sortOrder = searchParams.get("sortOrder") || "desc";

		// Validate pagination parameters
		if (page < 1 || limit < 1 || limit > 100) {
			return NextResponse.json<ApiResponse>(
				{
					message: TranslationErrorEnum.INVALID_PAGINATION_PARAMETERS,
					statusCode: 400,
					error: "Validation Error",
				},
				{ status: 400 }
			);
		}

		// Fetch user details
		const user = await prisma.user.findUnique({
			where: { id: payload.id },
			select: {
				id: true,
				email: true,
				isActive: true,
				teamMemberships: {
					select: {
						role: true,
						teamId: true,
						projectId: true,
					},
				},
			},
		});

		// Check if user exists and is active
		if (!user || !user.isActive) {
			return NextResponse.json<ApiResponse>(
				{
					message: TranslationErrorEnum.USER_DOES_NOT_EXIST,
					statusCode: 404,
					error: "User Error",
				},
				{ status: 404 }
			);
		}

		// Determine user's highest role from team memberships
		let userRole: TeamRole = TeamRole.MEMBER;

		if (
			user.teamMemberships.some(
				(membership) => membership.role === TeamRole.ADMIN
			)
		) {
			userRole = TeamRole.ADMIN;
		} else if (
			user.teamMemberships.some(
				(membership) => membership.role === TeamRole.MANAGER
			)
		) {
			userRole = TeamRole.MANAGER;
		}

		// Create user context for permission checking
		const userContext: UserContext = {
			id: user.id,
			role: userRole,
		};

		// Build where clause based on user role and filters
		let whereClause: any = {};

		if (userRole === TeamRole.ADMIN) {
			// ADMIN can only see own projects
			whereClause.ownerId = user.id;
		} else {
			// MANAGER/MEMBER can see projects they are connected to through teams
			const userTeamIds = user.teamMemberships.map(
				(membership) => membership.teamId
			);

			whereClause.teams = {
				some: {
					id: {
						in: userTeamIds.length > 0 ? userTeamIds : [null], // Handle case with no teams
					},
				},
			};
		}

		// Add search filter
		if (search) {
			whereClause.OR = [
				{ name: { contains: search, mode: "insensitive" } },
				{ description: { contains: search, mode: "insensitive" } },
			];
		}

		// Add status filter
		if (status) {
			whereClause.status = status;
		}

		// Calculate skip for pagination
		const skip = (page - 1) * limit;

		// Fetch projects with pagination
		const [projects, totalCount] = await Promise.all([
			prisma.project.findMany({
				where: whereClause,
				include: {
					owner: {
						select: {
							id: true,
							firstName: true,
							lastName: true,
							username: true,
							email: true,
							avatar: true,
						},
					},
					teams: {
						select: {
							id: true,
							name: true,
							_count: {
								select: {
									members: true,
								},
							},
						},
					},
					_count: {
						select: {
							tasks: true,
							teams: true,
						},
					},
				},
				orderBy: {
					[sortBy]: sortOrder,
				},
				skip,
				take: limit,
			}),
			prisma.project.count({
				where: whereClause,
			}),
		]);

		// Calculate pagination metadata
		const totalPages = Math.ceil(totalCount / limit);
		const hasNextPage = page < totalPages;
		const hasPrevPage = page > 1;

		// Return success response with pagination metadata
		return NextResponse.json<ApiResponse>(
			{
				message: TranslationEnum.PROJECT_RETRIEVED_SUCCESSFULLY,
				statusCode: 200,
				data: projects,
				meta: {
					pagination: {
						currentPage: page,
						perPage: limit,
						totalCount,
						totalPages,
						hasNextPage,
						hasPrevPage,
					},
					filters: {
						search,
						status,
						sortBy,
						sortOrder,
					},
				},
			},
			{ status: 200 }
		);
	} catch (error: any) {
		console.error("Error fetching projects:", error);

		return NextResponse.json<ApiResponse>(
			{
				message: TranslationErrorEnum.INTERNAL_SERVER_ERROR,
				statusCode: 500,
				error: "Projects Fetch Error",
				errors: error.message ? [error.message] : undefined,
			},
			{ status: 500 }
		);
	}
}

// Wrap handler with token validation and request timing middleware
export const GET = withRequestTiming(withTokenValidation(handleGetProjects));


Get Teams With Pagination : import {
	TranslationEnum,
	TranslationErrorEnum,
} from "@/interface/translation-enums";
import { prisma } from "@/lib/prisma";
import { ApiResponse } from "@/interface/api.interface";
import { NextRequest, NextResponse } from "next/server";
import { TeamRole, UserContext } from "@/lib/permission";
import { withRequestTiming } from "@/middleware/timestamp.middleware";
import { withTokenValidation } from "@/middleware/cookie-validate.middleware";

// GET /api/teams - Gets teams with pagination, permission checks, and project filtering
async function handleGetTeams(request: NextRequest): Promise<NextResponse> {
	try {
		const payload = (request as any)?.user;

		// Validate token payload
		if (!payload) {
			return NextResponse.json<ApiResponse>(
				{
					message: TranslationErrorEnum.UNAUTHORIZED,
					statusCode: 401,
					error: "Authentication Error",
				},
				{ status: 401 }
			);
		}

		// Extract query parameters
		const { searchParams } = new URL(request.url);
		const page = parseInt(searchParams.get("page") || "1");
		const limit = parseInt(searchParams.get("limit") || "10");
		const search = searchParams.get("search") || "";
		const projectId = searchParams.get("projectId") || "";
		const sortBy = searchParams.get("sortBy") || "createdAt";
		const sortOrder = searchParams.get("sortOrder") || "desc";

		// Validate pagination parameters
		if (page < 1 || limit < 1 || limit > 100) {
			return NextResponse.json<ApiResponse>(
				{
					message: TranslationErrorEnum.INVALID_PAGINATION_PARAMETERS,
					statusCode: 400,
					error: "Validation Error",
				},
				{ status: 400 }
			);
		}

		// Fetch user details with team memberships and project connections
		const user = await prisma.user.findUnique({
			where: { id: payload.id },
			select: {
				id: true,
				email: true,
				isActive: true,
				teamMemberships: {
					select: {
						role: true,
						teamId: true,
						projectId: true,
						team: {
							select: {
								projectId: true,
							},
						},
					},
				},
				createdTeams: {
					select: {
						id: true,
						projectId: true,
					},
				},
				createdProjects: {
					select: {
						id: true,
					},
				},
			},
		});

		// Check if user exists and is active
		if (!user || !user.isActive) {
			return NextResponse.json<ApiResponse>(
				{
					message: TranslationErrorEnum.USER_DOES_NOT_EXIST,
					statusCode: 404,
					error: "User Error",
				},
				{ status: 404 }
			);
		}

		// Validate projectId if provided
		if (projectId) {
			// Check if project exists
			const project = await prisma.project.findUnique({
				where: { id: projectId },
				select: { id: true },
			});

			if (!project) {
				return NextResponse.json<ApiResponse>(
					{
						message: TranslationErrorEnum.PROJECT_NOT_FOUND,
						statusCode: 404,
						error: "Project Error",
					},
					{ status: 404 }
				);
			}

			// Check if user has access to this project
			const userHasAccessToProject =
				// User is owner of the project
				user.createdProjects.some((p) => p.id === projectId) ||
				// User is member of a team in this project
				user.teamMemberships.some((m) => m.projectId === projectId) ||
				// User owns a team in this project
				user.createdTeams.some((t) => t.projectId === projectId);

			if (!userHasAccessToProject) {
				return NextResponse.json<ApiResponse>(
					{
						message: TranslationErrorEnum.PROJECT_ACCESS_DENIED,
						statusCode: 403,
						error: "Permission Error",
					},
					{ status: 403 }
				);
			}
		}

		// Determine user's highest role from team memberships
		let userRole: TeamRole = TeamRole.MEMBER;
		const userTeamIds: string[] = [];
		const userProjectIds: string[] = [];

		// Collect all team and project IDs the user is connected to
		user.teamMemberships.forEach((membership) => {
			userTeamIds.push(membership.teamId);
			userProjectIds.push(membership.projectId);

			// Determine highest role
			if (membership.role === TeamRole.ADMIN) {
				userRole = TeamRole.ADMIN;
			} else if (
				membership.role === TeamRole.MANAGER &&
				userRole !== TeamRole.ADMIN
			) {
				userRole = TeamRole.MANAGER;
			}
		});

		// Add projects user owns
		user.createdProjects.forEach((project) => {
			userProjectIds.push(project.id);
		});

		// Add teams user owns
		user.createdTeams.forEach((team) => {
			userTeamIds.push(team.id);
			userProjectIds.push(team.projectId);
		});

		// Create user context for permission checking
		const userContext: UserContext = {
			id: user.id,
			role: userRole,
		};

		// Build where clause based on user role and filters
		let whereClause: any = {};

		if (userContext.role === TeamRole.ADMIN) {
			// ADMIN can see all teams in projects they have access to
			whereClause.projectId = {
				in: userProjectIds.length > 0 ? userProjectIds : [null],
			};
		} else {
			// MANAGER/MEMBER can only see teams they are members of or own
			whereClause.OR = [
				{ id: { in: userTeamIds.length > 0 ? userTeamIds : [null] } },
				{ ownerId: user.id },
			];
		}

		// Add project filter if provided
		if (projectId) {
			whereClause.projectId = projectId;
		}

		// Add search filter
		if (search) {
			whereClause.OR = [
				...(whereClause.OR || []),
				{ name: { contains: search, mode: "insensitive" } },
				{ description: { contains: search, mode: "insensitive" } },
			];
		}

		// Calculate skip for pagination
		const skip = (page - 1) * limit;

		// Fetch teams with pagination
		const [teams, totalCount] = await Promise.all([
			prisma.team.findMany({
				where: whereClause,
				include: {
					owner: {
						select: {
							id: true,
							firstName: true,
							lastName: true,
							username: true,
							email: true,
							avatar: true,
						},
					},
					project: {
						select: {
							id: true,
							name: true,
							status: true,
						},
					},
					members: {
						select: {
							id: true,
							role: true,
							user: {
								select: {
									id: true,
									firstName: true,
									lastName: true,
									username: true,
									email: true,
									avatar: true,
								},
							},
						},
					},
					_count: {
						select: {
							members: true,
							tasks: true,
						},
					},
				},
				orderBy: {
					[sortBy]: sortOrder,
				},
				skip,
				take: limit,
			}),
			prisma.team.count({
				where: whereClause,
			}),
		]);

		// Calculate pagination metadata
		const totalPages = Math.ceil(totalCount / limit);
		const hasNextPage = page < totalPages;
		const hasPrevPage = page > 1;

		// Return success response with pagination metadata
		return NextResponse.json<ApiResponse>(
			{
				message: TranslationEnum.TEAM_RETRIEVED_SUCCESSFULLY,
				statusCode: 200,
				data: teams,
				meta: {
					pagination: {
						currentPage: page,
						perPage: limit,
						totalCount,
						totalPages,
						hasNextPage,
						hasPrevPage,
					},
					filters: {
						search,
						projectId,
						sortBy,
						sortOrder,
					},
					userContext: {
						role: userRole,
						teamCount: userTeamIds.length,
						projectCount: [...new Set(userProjectIds)].length, // Unique projects
					},
				},
			},
			{ status: 200 }
		);
	} catch (error: any) {
		console.error("Error fetching teams:", error);

		return NextResponse.json<ApiResponse>(
			{
				message: TranslationErrorEnum.INTERNAL_SERVER_ERROR,
				statusCode: 500,
				error: "Teams Fetch Error",
				errors: error.message ? [error.message] : undefined,
			},
			{ status: 500 }
		);
	}
}

// Wrap handler with token validation and request timing middleware
export const GET = withRequestTiming(withTokenValidation(handleGetTeams));


Permission Checker Lib Code : export enum ResourceType {
	PROJECT = "PROJECT",
	TEAM = "TEAM",
	TASK = "TASK",
	COMMENT = "COMMENT",
	ATTACHMENT = "ATTACHMENT",
	USER = "USER",
}

export enum Action {
	CREATE = "CREATE",
	READ = "READ",
	UPDATE = "UPDATE",
	DELETE = "DELETE",
	MANAGE = "MANAGE",
}

export enum TeamRole {
	ADMIN = "ADMIN",
	MANAGER = "MANAGER",
	MEMBER = "MEMBER",
}

// Interface for user context
export interface UserContext {
	id: string;
	role: TeamRole;
	// Add other user properties if needed for permission checks
}

// Interface for resource context (optional, for ownership checks)
export interface ResourceContext {
	ownerId?: string;
	teamId?: string;
	projectId?: string;
	// Add other resource-specific properties
}

// Permission matrix defining what each role can do
const permissionMatrix: Record<TeamRole, Record<ResourceType, Action[]>> = {
	[TeamRole.ADMIN]: {
		[ResourceType.PROJECT]: [
			Action.CREATE,
			Action.READ,
			Action.UPDATE,
			Action.DELETE,
			Action.MANAGE,
		],
		[ResourceType.TEAM]: [
			Action.CREATE,
			Action.READ,
			Action.UPDATE,
			Action.DELETE,
			Action.MANAGE,
		],
		[ResourceType.TASK]: [
			Action.CREATE,
			Action.READ,
			Action.UPDATE,
			Action.DELETE,
			Action.MANAGE,
		],
		[ResourceType.COMMENT]: [
			Action.CREATE,
			Action.READ,
			Action.UPDATE,
			Action.DELETE,
		],
		[ResourceType.ATTACHMENT]: [
			Action.CREATE,
			Action.READ,
			Action.UPDATE,
			Action.DELETE,
		],
		[ResourceType.USER]: [Action.READ, Action.MANAGE], // Admins can manage users within their scope
	},
	[TeamRole.MANAGER]: {
		[ResourceType.PROJECT]: [Action.READ], // Only read connected projects
		[ResourceType.TEAM]: [
			Action.CREATE,
			Action.READ,
			Action.UPDATE,
			Action.DELETE,
			Action.MANAGE,
		],
		[ResourceType.TASK]: [
			Action.CREATE,
			Action.READ,
			Action.UPDATE,
			Action.DELETE,
			Action.MANAGE,
		],
		[ResourceType.COMMENT]: [
			Action.CREATE,
			Action.READ,
			Action.UPDATE,
			Action.DELETE,
		],
		[ResourceType.ATTACHMENT]: [
			Action.CREATE,
			Action.READ,
			Action.UPDATE,
			Action.DELETE,
		],
		[ResourceType.USER]: [Action.READ],
	},
	[TeamRole.MEMBER]: {
		[ResourceType.PROJECT]: [Action.READ], // Only read connected projects
		[ResourceType.TEAM]: [Action.READ], // Only read connected teams
		[ResourceType.TASK]: [
			Action.CREATE,
			Action.READ,
			Action.UPDATE,
			Action.DELETE,
		],
		[ResourceType.COMMENT]: [
			Action.CREATE,
			Action.READ,
			Action.UPDATE,
			Action.DELETE,
		],
		[ResourceType.ATTACHMENT]: [
			Action.CREATE,
			Action.READ,
			Action.UPDATE,
			Action.DELETE,
		],
		[ResourceType.USER]: [Action.READ],
	},
};

// Additional ownership-based permissions
const ownershipPermissions: Partial<Record<ResourceType, Action[]>> = {
	[ResourceType.PROJECT]: [Action.UPDATE, Action.DELETE, Action.MANAGE],
	[ResourceType.TASK]: [Action.UPDATE, Action.DELETE],
	[ResourceType.COMMENT]: [Action.UPDATE, Action.DELETE],
	[ResourceType.ATTACHMENT]: [Action.UPDATE, Action.DELETE],
};

export class PermissionService {
	/**
	 * Check if a user has permission to perform an action on a resource
	 */
	static hasPermission(
		user: UserContext,
		action: Action,
		resourceType: ResourceType,
		resourceContext?: ResourceContext
	): boolean {
		// Get base permissions for the user's role
		const rolePermissions =
			permissionMatrix[user.role]?.[resourceType] || [];

		// Check if action is allowed by role
		if (rolePermissions.includes(action)) {
			return true;
		}

		// Check ownership-based permissions
		if (resourceContext?.ownerId && user.id === resourceContext.ownerId) {
			const ownerPermissions = ownershipPermissions[resourceType] || [];
			if (ownerPermissions.includes(action)) {
				return true;
			}
		}

		return false;
	}

	/**
	 * Check if user can access a specific resource based on ownership/association
	 */
	static canAccessResource(
		user: UserContext,
		resourceType: ResourceType,
		resourceContext: ResourceContext
	): boolean {
		// Owners can always access their resources
		if (resourceContext.ownerId && user.id === resourceContext.ownerId) {
			return true;
		}

		// Additional access logic based on resource type and user role
		switch (resourceType) {
			case ResourceType.PROJECT:
				// For projects, check if user is member of any team in the project
				// This would require additional service calls in real implementation
				return user.role === TeamRole.ADMIN;

			case ResourceType.TEAM:
				// For teams, check if user is a member
				// This would require checking team membership
				return user.role === TeamRole.ADMIN;

			case ResourceType.TASK:
				// For tasks, check if user is assigned or in the team
				return user.role !== TeamRole.MEMBER; // Simplified for example

			default:
				return true;
		}
	}

	/**
	 * Filter resources based on user permissions
	 */
	static filterResources<T extends ResourceContext>(
		user: UserContext,
		resources: T[],
		resourceType: ResourceType
	): T[] {
		return resources.filter((resource) =>
			this.canAccessResource(user, resourceType, resource)
		);
	}

	/**
	 * Check multiple permissions at once (useful for complex operations)
	 */
	static hasPermissions(
		user: UserContext,
		permissions: Array<{
			action: Action;
			resourceType: ResourceType;
			resourceContext?: ResourceContext;
		}>
	): boolean {
		return permissions.every((permission) =>
			this.hasPermission(
				user,
				permission.action,
				permission.resourceType,
				permission.resourceContext
			)
		);
	}
}

// Utility functions for common permission checks
export const PermissionChecks = {
	// Project permissions
	canCreateProject: (user: UserContext) =>
		PermissionService.hasPermission(
			user,
			Action.CREATE,
			ResourceType.PROJECT
		),

	canViewProject: (user: UserContext, project?: ResourceContext) =>
		PermissionService.hasPermission(
			user,
			Action.READ,
			ResourceType.PROJECT,
			project
		),

	canEditProject: (user: UserContext, project: ResourceContext) =>
		PermissionService.hasPermission(
			user,
			Action.UPDATE,
			ResourceType.PROJECT,
			project
		),

	canDeleteProject: (user: UserContext, project: ResourceContext) =>
		PermissionService.hasPermission(
			user,
			Action.DELETE,
			ResourceType.PROJECT,
			project
		),

	// Team permissions
	canCreateTeam: (user: UserContext) =>
		PermissionService.hasPermission(user, Action.CREATE, ResourceType.TEAM),

	canViewTeam: (user: UserContext, team?: ResourceContext) =>
		PermissionService.hasPermission(
			user,
			Action.READ,
			ResourceType.TEAM,
			team
		),

	canEditTeam: (user: UserContext, team: ResourceContext) =>
		PermissionService.hasPermission(
			user,
			Action.UPDATE,
			ResourceType.TEAM,
			team
		),

	canDeleteTeam: (user: UserContext, team: ResourceContext) =>
		PermissionService.hasPermission(
			user,
			Action.DELETE,
			ResourceType.TEAM,
			team
		),

	// Task permissions
	canCreateTask: (user: UserContext) =>
		PermissionService.hasPermission(user, Action.CREATE, ResourceType.TASK),

	canViewTask: (user: UserContext, task?: ResourceContext) =>
		PermissionService.hasPermission(
			user,
			Action.READ,
			ResourceType.TASK,
			task
		),

	canEditTask: (user: UserContext, task: ResourceContext) =>
		PermissionService.hasPermission(
			user,
			Action.UPDATE,
			ResourceType.TASK,
			task
		),

	canDeleteTask: (user: UserContext, task: ResourceContext) =>
		PermissionService.hasPermission(
			user,
			Action.DELETE,
			ResourceType.TASK,
			task
		),
};

PERMISSION i have decided
- ADMIN -> Create Projectd
- ADMIN -> Only Can see own created Projects
- Admin -> Only Update Own created projects
- Admin -> Create Teams, Tickets
- Admin -> Only can see own Projects -> Teams -> Tickets
- Admin -> Can invite user

- Manager -> Create Teams
- Manager -> Only Can see Connected Teams Projects
- Manager -> Create Teams, Tickets
- Manager -> Only can see Connected Teams Projects -> Teams -> Tickets

- MEMBER -> Only can create ticket, see connected teams with ticket and only can see connected teams project

Please memorize this all the code in you memory so i can proceed the development with you