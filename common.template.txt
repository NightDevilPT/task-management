Prisma Code : generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum TeamInviteStatus {
  PENDING
  ACCEPTED
  DECLINED
} 

enum TeamRole {
  ADMIN
  MANAGER
  MEMBER
}

enum ProjectStatus {
  ACTIVE
  ARCHIVED
  COMPLETED
  ON_HOLD
}

enum TaskStatusEnum {
  TODO
  IN_PROGRESS
  REVIEW
  DONE
  BLOCKED
}

enum TaskPriorityEnum {
  LOW
  MEDIUM
  HIGH
  URGENT
}

model User {
  id           String   @id @default(cuid())
  firstName    String
  lastName     String
  username     String   @unique
  email        String   @unique
  avatar       String?  // URL to avatar image
  isVerified   Boolean  @default(false)
  password     String
  otp          Int?     // For JWT to verify email or reset password
  otpExpiry    DateTime? @map("otp_expiry") // Expiry time for the token
  refreshToken String?  // For JWT refresh tokens
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")
  lastLogin    DateTime?
  isActive     Boolean  @default(true)
  
  // Relations
  teamMemberships TeamMember[]
  createdTeams    Team[]      @relation("TeamOwner")
  createdTasks    Task[]      @relation("TaskCreator")
  assignedTasks   Task[]      @relation("TaskAssignee")
  notifications   Notification[]
  activities      Activity[]
  teamInvites     TeamInvite[]
  comments        Comment[]
  attachments     Attachment[]
  createdProjects Project[] @relation("ProjectOwner")

  @@map("users")
}

model Project {
  id          String   @id @default(cuid())
  name        String
  description String?
  status      ProjectStatus @default(ACTIVE)
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  
  // Relations
  owner      User         @relation("ProjectOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId    String
  teams      Team[]
  tasks      Task[]
  activities Activity[]
  teamMembers TeamMember[] // Opposite relation for TeamMember.project
  teamInvites TeamInvite[] // Opposite relation for TeamInvite.project
  comments    Comment[]    // Opposite relation for Comment.project
  attachments Attachment[] // Opposite relation for Attachment.project
  notifications Notification[] // Opposite relation for Notification.project
  
  @@map("projects")
}

model Team {
  id          String   @id @default(cuid())
  name        String
  description String?
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  
  // Relations
  owner      User         @relation("TeamOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId    String
  project    Project      @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId  String
  members    TeamMember[]
  tasks      Task[]
  invites    TeamInvite[]
  activities Activity[]
  
  @@map("teams")
}

model TeamMember {
  id        String   @id @default(cuid())
  role      TeamRole @default(MEMBER)
  joinedAt  DateTime @default(now()) @map("joined_at")
  
  // Relations
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  team      Team    @relation(fields: [teamId], references: [id], onDelete: Cascade)
  teamId    String
  project   Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId String
  
  @@unique([userId, teamId])
  @@unique([userId, projectId, teamId]) // Ensure unique membership per project-team combination
  @@map("team_members")
}

model TeamInvite {
  id        String   @id @default(cuid())
  email     String
  role      TeamRole @default(MEMBER)
  token     String   @unique
  status   TeamInviteStatus   @default(PENDING) // e.g., PENDING, ACCEPTED, DECLINED
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")
  
  // Relations
  team      Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)
  teamId    String
  project   Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId String
  invitedBy User   @relation(fields: [invitedById], references: [id], onDelete: Cascade)
  invitedById String
  
  @@unique([email, teamId])
  @@map("team_invites")
}

model Task {
  id          String   @id @default(cuid())
  title       String
  description String?
  status      TaskStatusEnum   @default(TODO)
  priority    TaskPriorityEnum   @default(MEDIUM)
  dueDate     DateTime? @map("due_date")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  
  // Relations
  assignedTo  User?   @relation("TaskAssignee", fields: [assignedToId], references: [id], onDelete: SetNull)
  assignedToId String?
  createdBy   User    @relation("TaskCreator", fields: [createdById], references: [id], onDelete: Cascade)
  createdById String
  team        Team?   @relation(fields: [teamId], references: [id], onDelete: Cascade)
  teamId      String?
  project     Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId   String
  comments    Comment[]
  attachments Attachment[]
  activities  Activity[]
  
  @@map("tasks")
}

model Comment {
  id        String   @id @default(cuid())
  content   String
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  
  // Relations
  author    User   @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId  String
  task      Task   @relation(fields: [taskId], references: [id], onDelete: Cascade)
  taskId    String
  project   Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId String
  
  @@map("comments")
}

model Attachment {
  id        String   @id @default(cuid())
  filename  String
  url       String
  size      Int
  type      String
  createdAt DateTime @default(now()) @map("created_at")
  
  // Relations
  task      Task   @relation(fields: [taskId], references: [id], onDelete: Cascade)
  taskId    String
  uploadedBy User  @relation(fields: [uploadedById], references: [id], onDelete: Cascade)
  uploadedById String
  project   Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId String
  
  @@map("attachments")
}

model Notification {
  id        String   @id @default(cuid())
  title     String
  message   String
  type      String   // e.g., "TASK_ASSIGNED", "INVITE_RECEIVED", "COMMENT_ADDED"
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now()) @map("created_at")
  
  // Relations
  user      User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  project   Project? @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId String?
  
  @@map("notifications")
}

model Activity {
  id        String   @id @default(cuid())
  action    String   // e.g., "CREATE_TASK", "UPDATE_TASK", "JOIN_TEAM"
  details   String?
  createdAt DateTime @default(now()) @map("created_at")
  
  // Relations
  user      User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  team      Team?  @relation(fields: [teamId], references: [id], onDelete: Cascade)
  teamId    String?
  task      Task?  @relation(fields: [taskId], references: [id], onDelete: Cascade)
  taskId    String?
  project   Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectId String
  
  @@map("activities")
}

Reference Route Code : // app/api/auth/me/route.ts
import {
	TranslationEnum,
	TranslationErrorEnum,
} from "@/interface/translation-enums";
import {
	TokenPayload,
	withTokenValidation,
} from "@/middleware/cookie-validate.middleware";
import bcrypt from "bcryptjs";
import { prisma } from "@/lib/prisma";
import { validateEmail } from "@/lib/validator";
import { ApiResponse } from "@/interface/api.interface";
import { NextRequest, NextResponse } from "next/server";
import { withRequestTiming } from "@/middleware/timestamp.middleware";

async function meHandler(request: NextRequest, payload?: TokenPayload) {
	try {
		if (!payload) {
			const response: ApiResponse = {
				message: TranslationErrorEnum.UNAUTHORIZED,
				statusCode: 401,
				error: "Authentication Error",
			};
			return NextResponse.json(response, { status: 401 });
		}

		console.log(payload, "PAYLOAD");

		// Get user from database
		const user = await prisma.user.findUnique({
			where: { id: payload.id },
			select: {
				id: true,
				firstName: true,
				lastName: true,
				username: true,
				email: true,
				avatar: true,
				isVerified: true,
				isActive: true,
				createdAt: true,
				updatedAt: true,
				lastLogin: true,
			},
		});

		if (!user) {
			const response: ApiResponse = {
				message: TranslationErrorEnum.USER_DOES_NOT_EXIST,
				statusCode: 404,
				error: "User Error",
			};
			return NextResponse.json(response, { status: 404 });
		}

		if (!user.isActive) {
			const response: ApiResponse = {
				message: TranslationErrorEnum.USER_DEACTIVATED,
				statusCode: 403,
				error: "Account Error",
			};
			return NextResponse.json(response, { status: 403 });
		}

		// Create success response
		const response: ApiResponse = {
			message: TranslationEnum.USER_PROFILE_RETRIEVED,
			statusCode: 200,
			data: user,
		};

		return NextResponse.json(response, { status: 200 });
	} catch (error: any) {
		console.error("Get user profile error:", error);

		const response: ApiResponse = {
			message: TranslationErrorEnum.INTERNAL_SERVER_ERROR,
			statusCode: 500,
			error: "Profile Error",
			errors: error.message ? [error.message] : undefined,
		};

		return NextResponse.json(response, { status: 500 });
	}
}

async function updateMeHandler(request: NextRequest, payload?: TokenPayload) {
	try {
		if (!payload) {
			const response: ApiResponse = {
				message: TranslationErrorEnum.UNAUTHORIZED,
				statusCode: 401,
				error: "Authentication Error",
			};
			return NextResponse.json(response, { status: 401 });
		}

		const body = await request.json();
		const {
			firstName,
			lastName,
			username,
			email,
			avatar,
			currentPassword,
			newPassword,
		} = body;

		// Check if user exists and is active
		const existingUser = await prisma.user.findUnique({
			where: { id: payload.id },
		});

		if (!existingUser) {
			const response: ApiResponse = {
				message: TranslationErrorEnum.USER_DOES_NOT_EXIST,
				statusCode: 404,
				error: "User Error",
			};
			return NextResponse.json(response, { status: 404 });
		}

		if (!existingUser.isActive) {
			const response: ApiResponse = {
				message: TranslationErrorEnum.USER_DEACTIVATED,
				statusCode: 403,
				error: "Account Error",
			};
			return NextResponse.json(response, { status: 403 });
		}

		// Prepare update data
		const updateData: any = {};

		// Validate and set basic fields
		if (firstName !== undefined) {
			if (!firstName.trim()) {
				const response: ApiResponse = {
					message: TranslationErrorEnum.ALL_FIELDS_ARE_REQUIRED,
					statusCode: 400,
					error: "Validation Error",
				};
				return NextResponse.json(response, { status: 400 });
			}
			updateData.firstName = firstName.trim();
		}

		if (lastName !== undefined) {
			if (!lastName.trim()) {
				const response: ApiResponse = {
					message: TranslationErrorEnum.ALL_FIELDS_ARE_REQUIRED,
					statusCode: 400,
					error: "Validation Error",
				};
				return NextResponse.json(response, { status: 400 });
			}
			updateData.lastName = lastName.trim();
		}

		if (username !== undefined) {
			if (!username.trim()) {
				const response: ApiResponse = {
					message: TranslationErrorEnum.ALL_FIELDS_ARE_REQUIRED,
					statusCode: 400,
					error: "Validation Error",
				};
				return NextResponse.json(response, { status: 400 });
			}

			// Check if username is already taken by another user
			const existingUsername = await prisma.user.findFirst({
				where: {
					username: username.trim(),
					id: { not: payload.id },
				},
			});

			if (existingUsername) {
				const response: ApiResponse = {
					message: TranslationErrorEnum.USERNAME_ALREADY_EXISTS,
					statusCode: 409,
					error: "Validation Error",
				};
				return NextResponse.json(response, { status: 409 });
			}

			updateData.username = username.trim();
		}

		if (email !== undefined) {
			if (!email.trim()) {
				const response: ApiResponse = {
					message: TranslationErrorEnum.EMAIL_IS_REQUIRED,
					statusCode: 400,
					error: "Validation Error",
				};
				return NextResponse.json(response, { status: 400 });
			}

			if (!validateEmail(email)) {
				const response: ApiResponse = {
					message: TranslationErrorEnum.INVALID_EMAIL_FORMAT,
					statusCode: 400,
					error: "Validation Error",
				};
				return NextResponse.json(response, { status: 400 });
			}

			// Check if email is already taken by another user
			const existingEmail = await prisma.user.findFirst({
				where: {
					email: email.trim(),
					id: { not: payload.id },
				},
			});

			if (existingEmail) {
				const response: ApiResponse = {
					message: TranslationErrorEnum.EMAIL_ALREADY_EXISTS,
					statusCode: 409,
					error: "Validation Error",
				};
				return NextResponse.json(response, { status: 409 });
			}

			updateData.email = email.trim();
			// If email is changed, mark as unverified and generate new OTP
			if (email !== existingUser.email) {
				const otp = Math.floor(100000 + Math.random() * 900000); // 6-digit OTP
				updateData.isVerified = false;
				updateData.otp = otp;
				updateData.otpExpiry = new Date(Date.now() + 10 * 60 * 1000); // 10 minutes
				// TODO: Send verification email here
			}
		}

		if (avatar !== undefined) {
			updateData.avatar = avatar;
		}

		// Handle password change
		if (newPassword) {
			if (!currentPassword) {
				const response: ApiResponse = {
					message: TranslationErrorEnum.CURRENT_PASSWORD_REQUIRED,
					statusCode: 400,
					error: "Validation Error",
				};
				return NextResponse.json(response, { status: 400 });
			}

			// Verify current password
			const isCurrentPasswordValid = await bcrypt.compare(
				currentPassword,
				existingUser.password
			);
			if (!isCurrentPasswordValid) {
				const response: ApiResponse = {
					message: TranslationErrorEnum.INVALID_CURRENT_PASSWORD,
					statusCode: 400,
					error: "Validation Error",
				};
				return NextResponse.json(response, { status: 400 });
			}

			// Hash new password
			updateData.password = await bcrypt.hash(newPassword, 12);
		}

		// Update user
		const updatedUser = await prisma.user.update({
			where: { id: payload.id },
			data: updateData,
			select: {
				id: true,
				firstName: true,
				lastName: true,
				username: true,
				email: true,
				avatar: true,
				isVerified: true,
				isActive: true,
				createdAt: true,
				updatedAt: true,
			},
		});

		const response: ApiResponse = {
			message: TranslationEnum.USER_PROFILE_UPDATED,
			statusCode: 200,
			data: updatedUser,
		};

		return NextResponse.json(response, { status: 200 });
	} catch (error: any) {
		console.error("Update user profile error:", error);

		const response: ApiResponse = {
			message: TranslationErrorEnum.INTERNAL_SERVER_ERROR,
			statusCode: 500,
			error: "Update Error",
			errors: error.message ? [error.message] : undefined,
		};

		return NextResponse.json(response, { status: 500 });
	}
}

// Apply token validation middleware
const wrappedGetHandler = withTokenValidation(meHandler);
const wrappedPutHandler = withTokenValidation(updateMeHandler);

export const GET = withRequestTiming(wrappedGetHandler);
export const PUT = withRequestTiming(wrappedPutHandler);

Permission Checker Lib Code : export enum ResourceType {
	PROJECT = "PROJECT",
	TEAM = "TEAM",
	TASK = "TASK",
	COMMENT = "COMMENT",
	ATTACHMENT = "ATTACHMENT",
	USER = "USER",
}

export enum Action {
	CREATE = "CREATE",
	READ = "READ",
	UPDATE = "UPDATE",
	DELETE = "DELETE",
	MANAGE = "MANAGE",
}

export enum TeamRole {
	ADMIN = "ADMIN",
	MANAGER = "MANAGER",
	MEMBER = "MEMBER",
}

// Interface for user context
export interface UserContext {
	id: string;
	role: TeamRole;
	// Add other user properties if needed for permission checks
}

// Interface for resource context (optional, for ownership checks)
export interface ResourceContext {
	ownerId?: string;
	teamId?: string;
	projectId?: string;
	// Add other resource-specific properties
}

// Permission matrix defining what each role can do
const permissionMatrix: Record<TeamRole, Record<ResourceType, Action[]>> = {
	[TeamRole.ADMIN]: {
		[ResourceType.PROJECT]: [
			Action.CREATE,
			Action.READ,
			Action.UPDATE,
			Action.DELETE,
			Action.MANAGE,
		],
		[ResourceType.TEAM]: [
			Action.CREATE,
			Action.READ,
			Action.UPDATE,
			Action.DELETE,
			Action.MANAGE,
		],
		[ResourceType.TASK]: [
			Action.CREATE,
			Action.READ,
			Action.UPDATE,
			Action.DELETE,
			Action.MANAGE,
		],
		[ResourceType.COMMENT]: [
			Action.CREATE,
			Action.READ,
			Action.UPDATE,
			Action.DELETE,
		],
		[ResourceType.ATTACHMENT]: [
			Action.CREATE,
			Action.READ,
			Action.UPDATE,
			Action.DELETE,
		],
		[ResourceType.USER]: [Action.READ, Action.MANAGE], // Admins can manage users within their scope
	},
	[TeamRole.MANAGER]: {
		[ResourceType.PROJECT]: [Action.READ], // Only read connected projects
		[ResourceType.TEAM]: [
			Action.CREATE,
			Action.READ,
			Action.UPDATE,
			Action.DELETE,
			Action.MANAGE,
		],
		[ResourceType.TASK]: [
			Action.CREATE,
			Action.READ,
			Action.UPDATE,
			Action.DELETE,
			Action.MANAGE,
		],
		[ResourceType.COMMENT]: [
			Action.CREATE,
			Action.READ,
			Action.UPDATE,
			Action.DELETE,
		],
		[ResourceType.ATTACHMENT]: [
			Action.CREATE,
			Action.READ,
			Action.UPDATE,
			Action.DELETE,
		],
		[ResourceType.USER]: [Action.READ],
	},
	[TeamRole.MEMBER]: {
		[ResourceType.PROJECT]: [Action.READ], // Only read connected projects
		[ResourceType.TEAM]: [Action.READ], // Only read connected teams
		[ResourceType.TASK]: [
			Action.CREATE,
			Action.READ,
			Action.UPDATE,
			Action.DELETE,
		],
		[ResourceType.COMMENT]: [
			Action.CREATE,
			Action.READ,
			Action.UPDATE,
			Action.DELETE,
		],
		[ResourceType.ATTACHMENT]: [
			Action.CREATE,
			Action.READ,
			Action.UPDATE,
			Action.DELETE,
		],
		[ResourceType.USER]: [Action.READ],
	},
};

// Additional ownership-based permissions
const ownershipPermissions: Partial<Record<ResourceType, Action[]>> = {
	[ResourceType.PROJECT]: [Action.UPDATE, Action.DELETE, Action.MANAGE],
	[ResourceType.TASK]: [Action.UPDATE, Action.DELETE],
	[ResourceType.COMMENT]: [Action.UPDATE, Action.DELETE],
	[ResourceType.ATTACHMENT]: [Action.UPDATE, Action.DELETE],
};

export class PermissionService {
	/**
	 * Check if a user has permission to perform an action on a resource
	 */
	static hasPermission(
		user: UserContext,
		action: Action,
		resourceType: ResourceType,
		resourceContext?: ResourceContext
	): boolean {
		// Get base permissions for the user's role
		const rolePermissions =
			permissionMatrix[user.role]?.[resourceType] || [];

		// Check if action is allowed by role
		if (rolePermissions.includes(action)) {
			return true;
		}

		// Check ownership-based permissions
		if (resourceContext?.ownerId && user.id === resourceContext.ownerId) {
			const ownerPermissions = ownershipPermissions[resourceType] || [];
			if (ownerPermissions.includes(action)) {
				return true;
			}
		}

		return false;
	}

	/**
	 * Check if user can access a specific resource based on ownership/association
	 */
	static canAccessResource(
		user: UserContext,
		resourceType: ResourceType,
		resourceContext: ResourceContext
	): boolean {
		// Owners can always access their resources
		if (resourceContext.ownerId && user.id === resourceContext.ownerId) {
			return true;
		}

		// Additional access logic based on resource type and user role
		switch (resourceType) {
			case ResourceType.PROJECT:
				// For projects, check if user is member of any team in the project
				// This would require additional service calls in real implementation
				return user.role === TeamRole.ADMIN;

			case ResourceType.TEAM:
				// For teams, check if user is a member
				// This would require checking team membership
				return user.role === TeamRole.ADMIN;

			case ResourceType.TASK:
				// For tasks, check if user is assigned or in the team
				return user.role !== TeamRole.MEMBER; // Simplified for example

			default:
				return true;
		}
	}

	/**
	 * Filter resources based on user permissions
	 */
	static filterResources<T extends ResourceContext>(
		user: UserContext,
		resources: T[],
		resourceType: ResourceType
	): T[] {
		return resources.filter((resource) =>
			this.canAccessResource(user, resourceType, resource)
		);
	}

	/**
	 * Check multiple permissions at once (useful for complex operations)
	 */
	static hasPermissions(
		user: UserContext,
		permissions: Array<{
			action: Action;
			resourceType: ResourceType;
			resourceContext?: ResourceContext;
		}>
	): boolean {
		return permissions.every((permission) =>
			this.hasPermission(
				user,
				permission.action,
				permission.resourceType,
				permission.resourceContext
			)
		);
	}
}

// Utility functions for common permission checks
export const PermissionChecks = {
	// Project permissions
	canCreateProject: (user: UserContext) =>
		PermissionService.hasPermission(
			user,
			Action.CREATE,
			ResourceType.PROJECT
		),

	canViewProject: (user: UserContext, project?: ResourceContext) =>
		PermissionService.hasPermission(
			user,
			Action.READ,
			ResourceType.PROJECT,
			project
		),

	canEditProject: (user: UserContext, project: ResourceContext) =>
		PermissionService.hasPermission(
			user,
			Action.UPDATE,
			ResourceType.PROJECT,
			project
		),

	canDeleteProject: (user: UserContext, project: ResourceContext) =>
		PermissionService.hasPermission(
			user,
			Action.DELETE,
			ResourceType.PROJECT,
			project
		),

	// Team permissions
	canCreateTeam: (user: UserContext) =>
		PermissionService.hasPermission(user, Action.CREATE, ResourceType.TEAM),

	canViewTeam: (user: UserContext, team?: ResourceContext) =>
		PermissionService.hasPermission(
			user,
			Action.READ,
			ResourceType.TEAM,
			team
		),

	canEditTeam: (user: UserContext, team: ResourceContext) =>
		PermissionService.hasPermission(
			user,
			Action.UPDATE,
			ResourceType.TEAM,
			team
		),

	canDeleteTeam: (user: UserContext, team: ResourceContext) =>
		PermissionService.hasPermission(
			user,
			Action.DELETE,
			ResourceType.TEAM,
			team
		),

	// Task permissions
	canCreateTask: (user: UserContext) =>
		PermissionService.hasPermission(user, Action.CREATE, ResourceType.TASK),

	canViewTask: (user: UserContext, task?: ResourceContext) =>
		PermissionService.hasPermission(
			user,
			Action.READ,
			ResourceType.TASK,
			task
		),

	canEditTask: (user: UserContext, task: ResourceContext) =>
		PermissionService.hasPermission(
			user,
			Action.UPDATE,
			ResourceType.TASK,
			task
		),

	canDeleteTask: (user: UserContext, task: ResourceContext) =>
		PermissionService.hasPermission(
			user,
			Action.DELETE,
			ResourceType.TASK,
			task
		),
};

PERMISSION i have decided
- ADMIN -> Create Projectd
- ADMIN -> Only Can see own created Projects
- Admin -> Only Update Own created projects
- Admin -> Create Teams, Tickets
- Admin -> Only can see own Projects -> Teams -> Tickets
- Admin -> Can invite user

- Manager -> Create Teams
- Manager -> Only Can see Connected Teams Projects
- Manager -> Create Teams, Tickets
- Manager -> Only can see Connected Teams Projects -> Teams -> Tickets

- MEMBER -> Only can create ticket, see connected teams with ticket and only can see connected teams project

Please memorize this all the code in you memory so i can proceed the development with you